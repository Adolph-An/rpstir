Resource PKI Relying Party Database
Installation and Usage Manual
Version 2.0

1. Organization of this document

This document describes how to install and use the Resource PKI
relying party database.  Please refer to the design document,
rpkidesign.doc, for a detailed description of the various software
components in this release.

Section 2 of this document describes how to install that software,
including all its dependencies.  Section 3 provides a quick-start
guide on how to get your system running.  Section 4 describes the other
documents in the deliverable package. Finally, Appendix A provides
troubleshooting tips for some common problems.



2. Installation

    Contents
    2.1 Prerequisites
      2.1.1 OpenSSL
      2.1.2 MySQL
      2.1.3 cryptlib
      2.1.4 rsync
    2.2 RPKI Software
      2.2.1 Unpack the Source Code
      2.2.2 Customize the Makefiles
      2.2.3 Build the Executables
    2.3 RPKI User Account
      2.3.1 Environment Variables
    2.4 SSH Subsystem
    2.5 Self-Test

The RPKI software is distributed as source code that should be built
using the GNU build tools on Linux/Unix.  After reading this section,
you will know:
    . How to install and configure the prerequisites.
    . How to build the RPKI software.
    . How to set up a user with the correct environment.
    . How to validate the installation.
We assume that you can operate your system's package manager, as well
as build packages from source and do minor edits on Makefiles.


2.1 Prerequisites

2.1.1 OpenSSL

You must build OpenSSL from source in order to enable support for
RFC3779 X.509v3 extensions.  Download the latest source code (at least
version 0.9.8e) from http://www.openssl.org.  We recommend the default
installation target directory /usr/local/ssl.  As of version 0.9.8l,
the steps were:

	$ ./config enable-rfc3779
	$ make depend
	$ make
	$ make test
	$ make install

2.1.2 MySQL

Install the MySQL database server from http://mysql.org, at least
version 5.1.  We recommend the default installation target of
/usr/local/mysql, but this is not required.  Install the MySQL
Connector/ODBC driver from the same site, at least version 3.51, into
an accessible lib directory such as /usr/local/lib.  On many systems,
MySQL Connector/ODBC depends on unixODBC.  During later compilation of
the RPKI software, if you get a variety of link errors in the "proto"
directory, missing unixODBC is probably the problem.

Configure MySQL.  First, secure the initial MySQL accounts, which
includes setting a root password (see MySQL 5.1 manual, section
2.13.2).  Then set up a database user for RPKI.  For example, the
following creates a root password, then sets up a user with username
"rpki", password "bbn", and access to the database named "rpkidb7":

    shell> mysql -u root
    mysql> SELECT Host, User FROM mysql.user;  /* view all accounts */
    mysql> SET PASSWORD FOR 'root'@'127.0.0.1' = PASSWORD('rootpass');
    mysql> SET PASSWORD FOR 'root'@'localhost' = PASSWORD('rootpass');
    mysql> SET PASSWORD FOR 'root'@'<myhostname>' = PASSWORD('rootpass');
    mysql> CREATE USER 'rpki'@'localhost' IDENTIFIED BY 'bbn';
    mysql> GRANT ALL PRIVILEGES ON rpkidb7.* TO 'rpki'@'localhost';

Configure the Connector/ODBC driver.  We strongly recommend that you
give the MySQL root account a password in the ODBC initialization file
(typically /usr/local/etc/odbc.ini).  For example:
-----------------------------------------------------------------------------
;
;  odbc.ini configuration for Connector/ODBC and Connector/ODBC 3.51 drivers
;

[ODBC Data Sources]
myodbc3      = MyODBC 3.51 Driver DSN

[myodbc3]
Driver       = /usr/local/lib/libmyodbc3.so
Description  = Connector/ODBC 3.51 Driver DSN
SERVER       = localhost
PORT         =
USER         = root
Password     = rootpass
Database     = mysql
OPTION       = 3
SOCKET       =
-----------------------------------------------------------------------------

2.1.3 cryptlib

Install Peter Gutmann's cryptlib, currently available at
http://www.cs.auckland.ac.nz/~pgut001/cryptlib.  Ensure that both the
library itself and its include files are in accessible locations.  For
example, it may be necessary to manually copy libcl.so to
/usr/local/lib and cryptlib.h to /usr/local/include.  On FreeBSD this
can be done one of two ways: (1) using the package system by issuing
the command pkg_add -r cryptlib, or (2) using the ports system by
issuing the command make search name="cryptlib" from the /usr/ports
directory.

There seem to be some problems with compiling cryptlib on Linux machines.
You may need to modify some files to get it to build cleanly. Also note that
the self-test code (make testlib; ./testlib) fails on at least FreeBSD
and Linux. We do not currently think that this is cause for concern.

2.1.4 rsync

Your rsync should be at least version 2.6.9, as earlier versions do
not necessarily support the necessary flags.  Check your version with
rsync --version, and install from rsync.samba.org.


2.2 RPKI Software

2.2.1 Unpack the Source Code

The RPKI software will have been delivered to you as a gzip-ed tarball
named RPKI.tgz.  Gunzip using the command:

    gunzip RPKI.tgz
    
and then un-tar the resulting tarball using the command:

    tar xvpf RPKI.tar
    
This will create a directory named RPKI which will contain various
subdirectories.

2.2.1 Customize the Makefiles

In the top-level source directory there are some sample makefiles:
Makefile.linux for recent Linux distros, Makefile.linux24 for older
distros, and Makefile.bsd for NetBSD/FreeBSD.  Choose one depending on
your target environment.

You will most likely need to customize the Makefile to point to the
paths where the libraries listed above have been installed.  , one of
these three may work, or you may need to customize one by updating the
variables at the head of the file.  

You will need to edit the appropriate Makefile to link with the
correct libraries.  Note that the LIBODBC variable could either point
to -lmyodbc3 or -lmyodbc5, depending on what you installed above in
section 2.1.2.  In addition, you must edit proto/scmmain.h to point to
the correct DSN name, as specified in odbc.ini.

2.2.2 Build the Executables

Once the Makefile and header have been updated, build the executables
by issuing the command "make -f Makefile.<platform>" in the top-level
source directory.


2.3 RPKI User Account

There should be some established user account from which to run the
RPKI software.  This allows environment variables to be set
consistently between logins, assuming that the default values need to
be overridden.  It also provides a place, ~/.ssh/authorized_keys, to
put all the RPKI-RTR clients' public keys to allow SSH login.

<< comments on setting permissions to be friendly for some other users
>> Mark Reynolds: "It was my expectation that all processes other than
the query client would be run as rpki using cron jobs, but that the
permissions would be sufficiently open that an arbitrary user could
run query or could launch an rsync cycle using the sh script."

2.3.1 Environment Variables

    set environment variables: There are several environment variables
    used throughout the scripts and the code:
    RPKI_DB - the name of the MySQL database used to hold the RPKI data
    RPKI_PORT - the port number used for the loader and feeder to talk
    RPKI_ROOT - the full pathname of this directory (the top-level
      directory of the RPKI tree)
    RPKI_DBUSER - the username for logging into the MySQL database
    RPKI_DBPASS - the password for logging into the MySQL database, if any
    These environment variables will be set automatically to the
    following defaults by each of the scripts in the run_scripts directory:
    RPKI_DB = rpki
    RPKI_PORT = 7344
    RPKI_ROOT = ${HOME}/rpki/trunk
    RPKI_DBUSER = mysql
    RPKI_DBPASS = (none)
    If you ever want to run the code directly instead of running the
    scripts, make sure to set these yourself.
    
(RTR_RETENTION_HOURS, RTR_CHECK_INTERVAL?)

2.4 SSH Subsystem

Edit the /etc/ssh/sshd_config file to contain the line
  Subsystem	rpki-rtr	<RPKI_ROOT>/run_scripts/rtrServer.sh


3. Running the RPKI Software

The following are the steps required to run the RPKI software.  Note that
steps 1-4 only need to be executed once at the beginning if everything goes
completely as planned.  Steps 5-8 have to be run periodically even under
ideal circumstances.  It is recommended that the user create a script
to run these four steps and have a cron job that executes this script
periodically.  All scripts for steps 3-8 are in the run_scripts directory.

3.3 initDB.sh: This script deletes the database, if any, with the name
    RPKI_DB and sets up a new database with all the right tables.
    Be prepared to enter the root MySQL password twice.

3.4 loader.sh: This starts the process that receives data from the feeder
    and loads it into the database.  Under ideal circumstances, this will
    continue to run forever, waiting for inputs from the feeder.

3.5 pull_and_feed.sh: pull_and_feed.sh is a script that optionally pulls
    the data from a set of repositories using rsync and then optionally
    loads them into the database by feeding them to the loader.
    pull_and_feed.sh takes a single argument which is the name of a
    configuration file.  A sample configuration file called
    rsync_mock.config is included.  The configuration file tells the
    name of all remote repositories to be downloaded, the top-level
    directory for the local repository (with the REPOSITORY directory
    included here the suggested one), to top-level directory for storing
    the log files of the downloads (with LOGS the suggested directory),
    whether or not to do the repository pull, and whether or not to
    do the database feed.

    Note that you normally want to do the pull and the feed together.
    Only under special circumstances, such as an aborted feed, would you
    ever want to do one operation and not the other.

3.6 garbage.sh: This checks for certificates that may have expired due
    to the passage of time, or crls that may have become stale due to
    the passage of time, and takes the appropriate actions.  Any children
    certificates or roas of an expired certificate that are not reparented
    are marked as invalid, with this propagating down signing chains.
    Certificates, and their descendant certificates and roas, that might
    potentially be revoked by the updated version of a stale crl are set
    to an intermediate state of validity (called "unknown"), but are
    set back to valid if a current crl is available.

3.7 chaser.sh: This chases down objects from repositories that may
    not have been loaded but are required.  It checks the AIA, SIA
    and CRLDP fields of all certificates that arrived or have been
    modified since the last time this client was executed.  A list of
    other repositories to check is compiled.

    In the mode where the chaser automatically downloads all the
    other repositories, it requires only one argument, the full pathname
    of the configuration file used by rsync_pull.sh.

    Note that this can potentially download large numbers of duplicate
    copies of objects due to caching.  Therefore, there is a mode where
    you can execute this client to see what it would do without actually
    doing it.  You specify this mode by providing a second argument
    "noexec" or "NOEXEC".  It will print the name of the command it would
    execute along with creating a file chaser_rsync.config that is the
    configuration file it would feed to rsync_pull.sh.  You can then view
    the file and modify it as appropriate.

3.8 query.sh: This is the way to pull information out of the database and
    local repository.  There are two basic modes.

    The comprehensive query, indicated by the argument "-r", pulls all
    the valid ROAs from the repository and outputs a set of BGP filters
    in RPSL format specified by these ROAs.  To send the output to a
    file rather than the screen, include "-o <filename>" on the command
    line or just redirect the output. ROAs (as well as certificates and
    CRLs) can also be stale for a variety of reasons:
      - Validation Chain Stale: The ROA was validatated by a trust chain
        at some point, but now there is no longer a trust chain (e.g.,
        due to a certificate expiring or being revoked by a CRL).
      - Stale CRL: Some certificate in the ROA's trust chain is in
        the domain of a CRL that was supposed to be updated by a certain
        time and has not.
      - Stale Manifest: Similar to stale CRL
      - No Manifest: Either the ROA or some certificate in its trust
        chain is not on a validated manifest.
    For each type of staleness, it is possible to specify that the
    query consider ROAs that are stale in this manner to be either all
    valid or all invalid.  To control how different types of staleness are
    treated, use the "-s <filename>" option, where filename is a file
    in the same basic format as the sampleQuerySpecs file.  The
    sampleQuerySpecs file also has further documentation on the different
    types of filtering that can be specified.

    The informational query provides the user with a means to see what
    is in the database without directly executing MySQL commands.
    The basic informational query has the form
    ./query.sh -t <type> -d <field> [-d <field> ... -d <field>]
    where type is either cert, crl, roa or manifest, and the fields are all
    the fields of the objects to display.  There are different possible
    fields for each object type. The full list of possibilities
    is obtained with the command "query.sh -l <type>".
    Most of these fields also provide the capability for filtering
    the results based on a simple comparison.  To do such filtering,
    add as many "-f <field>.<op>.<value>" arguments to the command line
    as desired, where op is one of (eq, ne, lt, gt, le, ge) and value
    is unquoted and contains # characters to replaces spaces.
    Additional arguments are given if you type ./query.sh without
    any arguments.

3.9 rtrUpdate.sh: The process of performing the RPKI-RTR server functionality
    includes executing this script, with its one argument being the pathname
    of the staleness specifications file it should use, each time after
    executing the proceeding scripts.

3.10 IMPORTANT NOTE: Aborting any of the scripts that change the database
    or repository in the middle of operation can leave the database in
    an inconsistent state.  It is recommended that after any such abort,
    you re-initialize the database, clear the repository, and reload the
    data from scratch.  In the future, we plan to provide less drastic
    means of recovering from an abort.

4. Document resources

api.txt		API for the database, ASN.1 and ROA libraries
testplan.doc    Test plan
rpkidesign.doc	Top level design document
codereview.doc	Code review standards
rpkiaur.txt	rsync_aur/rcli socket communication protocol

Appendix A. Troubleshooting

A.1 Database troubleshooting

If you are having database errors, particularly when you first attempt to
use rcli, it is important to check and make sure that your MySQL installation
is correct.  Try the following command:

    mysql --user=mysql

This should connect you to the database and give a "mysql> " prompt back. If
it does not, then your MySQL and/or ODBC installation is not correct. Check
the troubleshooting section of the MySQL documentation. Verify that your ODBC
information, in /usr/local/etc/odbc.ini and /usr/local/etc/odbcinst.ini, is
correct.  Verify that the MySQL daemon process mysqld is running using "ps -ef".
Verify that there is a mysql socket named mysql.sock, typically in /tmp.

Once you can successfully connect to the database as user "mysql" try
connecting as root by issuing the command:

    mysql --user=root --password=PWD

where PWD is the root password specified in your odbc.ini file. If this does
not succeed, follow the steps given in the MySQL manual for resetting the
root password, then stop and restart the mysqld process.
