RSYNC Script(s) and RSYNC_AUR Component(s)


The Problem: Remote repositories need to be synchronized locally. 
Any changes that are noted during the synchronization need to be 
conveyed to the Database.

The solution: A cron job is created that calls one of our scripts. 
Said script first performs log rotation on any existing log files and 
then synchronizes the remote repositories that are specified in its 
internal configuration variables, recording the transactions. 
The rsync_aur program is run over the existing log file and parses 
its content to create Add, Update, and Remove messages. These messages 
are sent via UDP or TCP on the local system to a program that will 
act upon the messages to modify the database accordingly.
 
There are four components to this system:
 
1. rsync itself
 
It must be run with the -i and --del flags in order to generate 
a logfile of its processing, and to create Remove events.
 
2. The AUR program
 
This program operates on the rsync logfile generated by #1 and sends 
"events" to the rsync daemon.  Events are just a fancy way of saying 
"strings sent over a socket".  The AUR program should accept a command 
line argument specifying the port to which AUR messages are sent, 
e.g. -t 4444 for TCP port 4444 or -u 3937 for UDP port 3937, for example.
 
3. A wrapper script
 
This script calls #1 and #2 with the appropriate options. The script is 
currently setup to run daily from cron(8).

[crontab]
# use /bin/sh to run commands, no matter what /etc/passwd says
SHELL=/bin/sh
#
SCRIPT=/home/mudge/rsync_aur/SCRIPTS/rsync_pull.sh
# run five minutes after midnight, every day
5 0 * * *       ${SCRIPT}

[The script itself]
#!/bin/sh
RSYNC=/usr/local/bin/rsync
DIRS="APNIC mock knownRIRs mockisp TRUSTANCHORS"
REPOSITORY=/home/mudge/rsync_aur/REPOSITORY
LOGS=/home/mudge/rsync_aur/LOGS
system=repository.apnic.net

cd ${LOGS}
echo "Rotating rpki rsync logs"

for arg in ${DIRS}
do
  for i in ${arg}
  do
    if [ -f "${i}.log.6" ]; then mv -f "${i}.log.6" "${i}.log.7"; fi
    if [ -f "${i}.log.5" ]; then mv -f "${i}.log.5" "${i}.log.6"; fi
    if [ -f "${i}.log.4" ]; then mv -f "${i}.log.4" "${i}.log.5"; fi
    if [ -f "${i}.log.3" ]; then mv -f "${i}.log.3" "${i}.log.4"; fi
    if [ -f "${i}.log.2" ]; then mv -f "${i}.log.2" "${i}.log.3"; fi
    if [ -f "${i}.log.1" ]; then mv -f "${i}.log.1" "${i}.log.2"; fi
    if [ -f "${i}.log" ]; then mv -f "${i}.log" "${i}.log.1"; fi
  done
done

for arg in ${DIRS}
do
  echo "retrieving ${arg}"
  $RSYNC -airz --del rsync://${system}/${arg} ${REPOSITORY}/${arg} > \
        ${LOGS}/${arg}.log
done

 
4. The rsync "client" (not to be confused with rsync(1))
 
This client will be listening on a socket (port provided on the command 
line, as with #2).
 
This document only deals with elements {1,2,3}.

The rsync_aur program

The program parses the log file created by the rsync program and creates 
messages to be sent to the rsync client (which is in actuality a server to 
the rsync_aur program and a client of the database). 

Socket messages are unidirectional; there are no replies or acks from 
the rsync client. The socket messages might have the following form:
 
TAG whitespace VALUE CRLF
 
The following messages are being used:
 
B (begin).  This is sent when the AUR program starts. Its VALUE is the 
current date and time.
 
E (end).  Sent when the AUR program is done. VALUE is the current date 
and time. AUR may close its end of the socket immediately after sending 
this message; it need not wait.
 
A (add). Sent when a file is added to the repository. VALUE is the full, 
absolute path to the file.
 
U (update). Sent when a file is updated in the repository, e.g. the 
contents change but the filename remains the same and is in the same 
directory.
 
R (remove). Sent when a file is removed from the repository.  VALUE is 
the full path to the file.
 
L (link). Sent when a link (hard or symbolic) is made between two files 
in the repository. VALUE is formed as follows: "filename1" SP filename2.  
Filename1 is a full pathname in double quotes; it is followed by a 
single space, and then filename2, which is also a full pathname. The 
link direction is filename1 -> filename2. [This needs to be formalized as 
to which is the link and which is the actual file]
 
F (fatal error). Sent (if possible) when the AUR program detects an 
unrecoverable error occurs. VALUE is the error text. It is expected that 
AUR will immediately close its end of the socket when this happens 
(perhaps even without being able to send an message).

X (error). Sent when an error occurs. VALUE is error text.  Optional 
message. Command line flags specify whether these messages should be 
generated and sent.

W (warning). Sent when a warning occurs. VALUE is warning text. 
Optional message. Command line flags specify whether these messages 
should be generated and sent.

I (information). Sent to convey arbitrary information.  VALUE is the 
informational text. Optional message. Command line flags specify whether 
these messages should be generated and sent.
 
Note that there is no escaping of characters within the filename. 
This might need to be revisited in the future for Unicode strings. 

Originally it was proposed that CR and LF be escaped with 
their '\013' and '\010' values respectively. The issue with this is that we 
are parsing a log file that separates entries via new lines. Using fgets(), 
which reads up to a newline automatically, or any other input such as 
read(), where we would be taking input until a newline was seen 
programmatically, it is impossible for us to have embedded CR and LF 
values within a line. 

It was decided that escaping other values (e.g. `'"*<>,:^ etc.) will not 
be performed as the software  uses C library interfaces for open(), 
close(),  etc. and only the shell needs such values escaped for security 
reasons.

The rsync_aur client already sanity checks the log file entry lines 
for having  the correct %i format description, the correct character at 
the  beginning of the line to specify the type of entry the line is, and  
in the case of update or something that is expecting a filename a check 
is performed to verify that there is a legitimate extension 
present (.der, .cer, .pem, .crl, or .roa (case insensitive) OBNOTE: what
in the world would have a .der file extension... oh well).
 
Note also that it is the responsibility of the rsync client to detect 
unexpected termination (death of peer, e.g. AUR) on the socket.  AUR 
should send an Fatal and/or Warning if possible, but there could be 
conditions in which AUR might be unable to do so.  It is expected that 
AUR will at least arrange to handle ^C from the user, as well as other 
common signals, and attempt to terminate gracefully.

