= Introduction =

The RPSTIR software uses a SQL database to keep track of its local cache of the global Resource Public Key Infrastructure (RPKI).
The database speeds up common use cases by allowing RPSTIR to cryptographically check the validity and freshness of each affected object as new objects are added instead, of needing to check for each query of the RPKI.
It's generally assumed RPKI objects will be read more than they will be added or updated.

There are various types of objects in RPKI that need to be represented by the database.
Trust Anchors are certificates that are trusted via external means to sign any CA or EE certificate.
CA certificates are certificates that may sign other CA or EE certificates, but may only grant those certificates resources it possesses itself.
EE certificates are signed by CA certificates are used to sign things other than certificates.
CRLs are lists of revoked certificates, signed by a CA certificate.
CMS objects are files that contain both an EE certificate signed by a CA and a blob of data signed by the EE.
CMS objects do not need to be stored in the database, except as a recognized more specific type below combined with an EE certificate.
Manifests are lists of files and their hashes in a directory, signed and stored as a CMS object and used to check the contents of a directory.
ROAs are lists of IP prefixes authorized to be announced by a specified AS number, signed and stored as a CMS object.
Additionally, the rpstir database is used by the RTR server to store snapshots of ROA data at each serial number and to store the differences between these snapshots.


= Requirements =

== Common Operations and Queries ==

Adding any file other than a manifest:
 * Check manifest if hashes match.
 * If all files on the manifest are present and there are no files not on the manifest, mark all relevant files as manifest-clean.
 * If the new file is not on the manifest, mark all relevant files as not manifest-clean.

Adding a cert:
 * Find parent cert's validity.
 * Check CRL(s) if the cert is revoked.
 * If the cert has a chain to a chained cert, recurse over the certs children:
  * If the child is a ROA with unchecked IP prefixes, check the IP resources (see "Adding a ROA").
  * Mark the child as chained.

Adding or Updating a CRL:
 * Find parent cert's validity.
 * If the new CRL is cryptographically newer than the old CRL, delete the old CRL.
 * Check all covered certs to see if they're revoked.

Adding a manifest:
 * If the new manifest is cryptographically newer than the old manifest, delete the old manifest and set all covered files as not manifest-clean.
 * Check all covered files' hashes.
 * If the files all match and there are no extra or missing files, mark all the files as manifest-clean.

Adding a ROA:
 * Recursively find the closest parent cert that doesn't have the inherit bit set for IP addresses.
 * If there is one, check that the ROAs prefixes are a subset of the above cert's IP resources.
 * If there is no parent with inherit not set, mark the ROA as needing checking.

Expiring or revoking a cert:
 * Recurse over the children:
  * Mark the child as not chained.
  * If the child is a ROA and all certs between the removed cert and the ROA have inherit set, mark the ROA as needing checking.
 * Remove the cert.

Finding all valid ROAs:
 * Query for all ROA data given a set of flags (e.g. chained, manifest-clean, and not needs checking).

== Performance ==

TODO: algorithm complexity, e.g. adding a CRL or adding a bunch of certs and testing against a CRL

== Scope ==

In general, any data item that can only be used by operations that require the entire file should not go in the database.
Other file fields should go in the database unless they would impose significant overhead and aren't needed at the current time.
For example, the signature of a certificate can only be used in combination with the entire certificate and its parent's public key, so the signature should not go in the database.
On the other hand, the list of revoked certificates in a CRL can be used knowing only the serial number of a certificate covered by that CRL, so the list should go in the database.

== Authenticated Deletion and Update ==

A malicious person with access to a repository but not the CA private key should not be able to cause removal of an RPKI object or revert an object to a previous version.
To address this, the database may need to reference multiple files with the same URI.
This is done by storing files by their file hash and mapping URIs to unique files, which has the additional benefit of reducing space requirements if there are duplicated files.
