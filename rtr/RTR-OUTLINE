Problems to figure out:
 * In the current design, the connection control thread can spin on a socket that's read-ready, incrementing the corresponding semaphore many times before the connection thread reads all available data.
  * Possible fix: after incrementing a semaphore, remove the socket from the FD_SET and have the connection thread add it back somehow. This is probably problematic though.
 * The database thread should be able to sleep until either there's a new request to handle or one of the response queues it's servicing is shorter than a specific limit. This may be difficult.


Main thread:
  Create listening connection.
  Make queue of requests to the database {request, queue, semaphore}.
  Make a global notify state with a write-once/read-many lock, currently just the latest serial number.
  Call notify state update function on the global notify state.
  Spawn a number of database threads, each with the request queue.
  Spawn a connection control thread, with the listening socket, request queue, and global notify state
  Loop indefinitely:
    Sleep for some amount of time.
    Check the load on the database threads, adding or removing threads as needed.
    Call notify state update function on the global notify state.

Notify state update function:
  Static variable connection.
  If the connection isn't already present:
    Connect to database.
  Update the global notify state based on database queries.
 
Database thread:   
  Connect to database.
  ...

Connection control thread:
  Create a map of connection socket to semaphore.
  Loop indefinitely:
    select() on the listening socket and all connection sockets in the map.
    For each connection socket that's read-ready:
      Lookup the socket in the map and increment the associated semaphore.
    If the listening socket is accept-ready:
      accept()
      Create a semaphore.
      Add the just-created socket and semaphore to the map.
      Spawn a connection thread with the connection socket, semaphore, the global request queue, and the global notify state.

Connection thread:
  Create a queue of responses from the database {request, bool is_done, array of response PDUs}. // NOTE: this only has responses to one request at a time
  Create a local queue of parsed and validated PDUs to be processed when the current response is done.
  Create a PDU reassembly buffer of constant size.
  Create a state variable in the READY state.
  Create a local notify state as a non-locked copy of the global notify state.
  Loop indefinitely:
    Block for at most some time interval, trying to decrement the semaphore.
    If the socket is read-ready:
      Block, reading and appending to the buffer only enough bytes to get the length field.
      If the partial PDU is invalid or the length is too large for the reassembly buffer:
        Send an error report PDU and log an error.
        Quit thread.
      Block, reading and appending to the buffer as many bytes as the length field specifies.
      Parse the PDU.
      If the PDU can be handled/responded to without any database interaction in the current state:
        Block, handling/responding as necessary.
      Else if state is RESPONDING:
        Add the PDU to the queue of to-be-processed PDUs.
      Else:
        Add (request, response queue, our semaphore) to the database request queue.
        Set state to RESPONDING.
    Else if there is something on the response queue:
      Pop it from the queue.
      If the response indicates an update to local notify state:
        Update local notify state as appropriate.
      Block, sending the response.
      If its is_done is true:
        Set state to READY.
        While the to-be-processed queue is nonempty and state is READY:
          Pop the to-be-processed queue.
          If the PDU can be handled/responded to without any database interaction:
            Block, handling/responding as necessary.
          Else:
            Add (request, response queue, our semaphore) to the database request queue.
            Set state to RESPONDING.
    If state is READY:
      Create tmp notify state as a non-locked copy of the global notify state.
      If local notify state is earlier than tmp notify state:
        Block, sending notify PDU(s) for the differences from local notify state to tmp notify state.
        Set local notify state to tmp notify state.
