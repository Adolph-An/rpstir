Problems to figure out:
 * In the current design, the connection control thread can spin on a socket that's read-ready, incrementing the corresponding semaphore many times before the connection thread reads all available data.
  * Possible fix: after incrementing a semaphore, remove the socket from the FD_SET and have the connection thread add it back somehow. This is probably problematic though.


Main thread:
  Create listening connection.
  Make queue of requests to the database {request, queue, semaphore}.
  Make a vector of semaphores for the request queue.
  Make a global notify state with a write-once/read-many lock, currently just the latest serial number.
  Call notify state update function on the global notify state.
  Repeat as many times as the desired initial number of database threads:
    Create a semaphore.
    Add the semaphore to the request queue's vector of semaphores.
    Spawn a database thread with the semaphore and request queue.
  Spawn a connection control thread, with the listening socket, request queue and its semaphores, and global notify state
  Loop indefinitely:
    Sleep for some amount of time.
    Check the load on the database threads, adding or removing threads as needed.
    Call notify state update function on the global notify state.

Notify state update function:
  Static variable connection.
  If the connection isn't already present:
    Connect to database.
  Update the global notify state based on database queries.
 
Database thread:   
  Connect to database.
  Create currently processing vector of {request, response queue, response semaphore, database statement handle}.
  Configured parameter buffer length: number of responses to buffer per request.
  Loop indefinitely:
    Block, trying to decrement the semaphore.
    Let operation completed = false.
    For each member of currently processing:
      If the length of the response queue is less than the buffer length:
        Fetch more data from the statement handle into an array of PDUs.
        Let is_done = false.
        Let more data semaphore = our semaphore.
        If the statement handle is at the end:
          Let is_done = true.
          Let more data semaphore = NULL.
          Remove this member from currently processing.
          Append an end-of-data PDU to the array of PDUs.
        Add (request, is_done, array of PDUs, more data semaphore) to response queue.
        Increment response semaphore.
        Let operation completed = true.
        Break the for loop.
    If there's a new request on the request queue and not operation completed:
      Pop the request queue.
      Create a new statement handle for the request with the appropriate query.
      Add (request, response queue, response semaphore, handle) to currently processing.
      Add (request, false, array {start-of-data PDU} of PDUs, our semaphore) to response queue.
      Increment response semaphore.
      Increment our semaphore by buffer length - 1.

Connection control thread:
  Create a map of connection socket to semaphore.
  Loop indefinitely:
    select() on the listening socket and all connection sockets in the map.
    For each connection socket that's read-ready:
      Lookup the socket in the map and increment the associated semaphore.
    If the listening socket is accept-ready:
      accept()
      Create a semaphore.
      Add the just-created socket and semaphore to the map.
      Spawn a connection thread with the connection socket, semaphore, the global request queue and its semaphores, and the global notify state.

Connection thread:
  Create a queue of responses from the database {request, bool is_done, array of response PDUs, more data semaphore}. // NOTE: this only has responses to one request at a time
  Create a local queue of parsed and validated PDUs to be processed when the current response is done.
  Create a PDU reassembly buffer of constant size.
  Create a state variable in the READY state.
  Create a local notify state as a non-locked copy of the global notify state.
  Loop indefinitely:
    Block for at most some time interval, trying to decrement the semaphore.
    If the socket is read-ready:
      Block, reading and appending to the buffer only enough bytes to get the length field.
      If the partial PDU is invalid or the length is too large for the reassembly buffer:
        Send an error report PDU and log an error.
        Quit thread.
      Block, reading and appending to the buffer as many bytes as the length field specifies.
      Parse the PDU.
      If the PDU can be handled/responded to without any database interaction in the current state:
        Block, handling/responding as necessary.
      Else if state is RESPONDING:
        Add the PDU to the queue of to-be-processed PDUs.
      Else:
        Add (request, response queue, our semaphore) to the database request queue and increment each of the queue's semaphores.
        Set state to RESPONDING.
    Else if there is something on the response queue:
      Pop it from the queue.
      If the more data semaphore is not NULL:
        Increment the more data semaphore.
      If the response indicates an update to local notify state:
        Update local notify state as appropriate.
      Block, sending the response.
      If its is_done is true:
        Set state to READY.
        While the to-be-processed queue is nonempty and state is READY:
          Pop the to-be-processed queue.
          If the PDU can be handled/responded to without any database interaction:
            Block, handling/responding as necessary.
          Else:
            Add (request, response queue, our semaphore) to the database request queue and increment each of the queue's semaphores.
            Set state to RESPONDING.
    If state is READY:
      Create tmp notify state as a non-locked copy of the global notify state.
      If local notify state is earlier than tmp notify state:
        Block, sending notify PDU(s) for the differences from local notify state to tmp notify state.
        Set local notify state to tmp notify state.
