=====================================
Top-level requirements for RTR server
-------------------------------------

T1. Provide timely, validated route origin information to multiple
    router clients, as specified in
    http://datatracker.ietf.org/doc/draft-ietf-sidr-rpki-rtr/

T2. Security requirement: Availability of route origin information.
    Client A must not be able to deny service to client B.

T3. Security requirement: (Currently optional) Integrity of route
    origin information.  RTR spec lists options such as TCP-AO, SSH,
    IPsec, and TLS.

Threat Model:

* Who/Motivation: Adversary wishing to alter routing through DoS of
  RTR server.
  
* Capability: Fully control/impersonate one or more RTR clients.  Can
  initiate arbitrary client connections, and send arbitrary data over
  RTR transport.

Explicit non-requirements:

* Confidentiality of route origin information is not required, since
  the information is publicly available.


===================================
Derived requirements for RTR server
-----------------------------------

D1. (Derived from T1). The RTR server will create periodic snapshots
    of the validated cache of ROAs, computing diffs and setting a new
    serial number each time.

D2. (Derived from T2). Basic authentication of client: firewall.  The RTR
    server is ASSUMED to sit behind a firewall that will (1) limit RTR
    clients to a set of pre-configured IP addresses, and (2) limit the
    number of concurrent connections from each IP address.
    
D3. (Derived from T2). Rate limit on queries.  The RTR server must limit
    the number of queries per connection, possibly by type of query, since
    reset queries can be expensive.

D4. (Derived from T1 and T2). Threads and timeouts.  Another way to abuse the
    system is when the server reads a message from a client and the
    actual transmission rate is *purposefully* very low. This should
    not stall all other clients.

D5. (Derived from T3). Future support for authenticated transport.
    RTR server is initially designed to support vanilla TCP only.
    Advanced functionality can be obtained through network shims such
    as netcat/ssh-subsystem, or stunnel.

D6. (Derived from T1 and T2).  The server should handle graceful
    shutdown, e.g. due to signal reception such as SIGINT.  A signal
    should not abruptly terminate the server process, which is the
    default behavior, but instead perform a graceful shutdown of all
    active connections. Signal handling procedure must be carefully
    written since it can easily induce race-conditions.

D7. (Derived from T1 and D2).  TCP keepalive.  To prevent inactivity
    from disconnecting the channel (e.g. due to firewall), and to
    reliably detect dead peers, keepalive should be enabled if the
    underlying OS supports it.


=======================
Problems to figure out:
-----------------------

 * In the current design, the connection control thread can spin on a socket that's read-ready, incrementing the corresponding semaphore many times before the connection thread reads all available data.
  * Possible fix: after incrementing a semaphore, remove the socket from the FD_SET and have the connection thread add it back somehow. This is probably problematic though.


===============
Design Overview
---------------

Threads (and short name as used below):
 . Main thread (main)
 . Database threads (db)
 . Connection control thread (cxnctl)
 . Connection threads (cxn)

Configuration parameters and constants:
 . initial_db_threads: number of db threads to start initially
 . main_loop_interval: number of seconds for main to sleep between each run through its management loop
 . db_response_length: number of records query for and include in a single db_response_t
 . db_response_buffer_length: number of db_response_t's to buffer in a db_response_queue_t per db_request_t
 . max_PDU_size: largest PDU to attempt to parse
 . cxn_notify_check_interval: maximum number of seconds (more or less) that connection should wait between checks if the global notify state has changed

Data and synchronization types and structures:
 . socket_fd_t: whatever the system wants it to be
 . db_connection_t: whatever ODBC wants it to be

 . notify_state_t: serial number
 . global_notify_state_t: {notify_state_t notify_state, rwlock_t lock}

 . db_query_t: something that indicates what the router/client wants
 . db_query_progress_t: something that indicates where in a suspended SQL query to pick up

 . PDU_t: data of a parsed and valid PDU
 . PDU_buffer_t: uint8_t[max_PDU_size]

 . cxn_semaphore_t: semaphore that a cxn thread waits for
 . db_semaphore_t: semaphore that a db thread waits for

 . db_request_t: {db_query_t query, db_response_queue_t response_queue, cxn_semaphore_t response_semaphore}
 . db_request_queue_t: thread-safe queue of db_request_t

 . db_response_t: {PDU_t[] PDUs, bool is_done, db_semaphore_t more_data_semaphore}
 . db_response_queue_t: thread-safe queue of db_response_t

 . db_run_state_t: {db_request_t request, db_query_progress_t progress}

 . cxnctl_socket_map_t: map of socket_fd_t to cxn_semaphore_t

 . cxn_state_t: enum {READY, RESPONDING}


Variables (not including short-lived local variables):
+-----------------------+------------------------------+------------+--------------+
| Type                  |  Variable                    | Created by | Used by      |
+-----------------------+------------------------------+------------+--------------+
| socket_fd_t           | listen_fd                    | main       | cxnctl
| db_request_queue_t    | db_request_queue             | main       | db, cxn
| db_semaphore_t[]      | db_semaphores_all            | main       | cxn
| global_notify_state_t | global_notify_state          | main       | main, cxn
| db_semaphore_t        | db_semaphore per db thread   | main       | db
| db_connection_t       | notify().connection          | main       | main
| db_connection_t       | <unnamed>                    | db         | db
| db_run_state_t[]      | currently_processing         | db         | db
| cxnctl_socket_map_t   | socket_map                   | cxnctl     | cxnctl
| socket_fd_t           | cxn_socket per cxn thread    | cxnctl     | cxnctl, cxn
| cxn_semaphore_t       | cxn_semaphore per cxn thread | cxnctl     | cxnctl, cxn

Note that `[]' is used to denote a container, not necessarily a C array.


===============
Detailed Design
---------------

Main thread:
  Make a socket_fd_t listen_fd in the listening state.
  Make a db_request_queue_t db_request_queue.
  Make a db_semaphore_t[] db_semaphores_all.
  Make a global_notify_state_t global_notify_state.
  Call notify state update function on (global_notify_state).
  Repeat initial_db_threads times:
    Make a db_semaphore_t db_semaphore.
    Add db_semaphore to db_semaphores_all.
    Spawn a database thread with (db_semaphore, db_request_queue).
  Spawn a connection control thread with (listen_fd, db_request_queue, db_semaphores_all, global_notify_state).
  Loop indefinitely:
    Sleep for main_loop_interval seconds.
    Check the load on the database threads, adding or removing threads as needed.
    Call notify state update function on (global_notify_state).

Notify state update function (global_notify_state_t global_notify_state):
  Static db_connection_t connection.
  If connection isn't connected:
    Connect to database.
  Acquire global_notify_state.lock for writing.
  Update global_notify_state.notify_state based on a database query.
  Release global_notify_state.lock.
 
Database thread (db_semaphore_t db_semaphore, db_request_queue_t db_request_queue):
  Connect to database.
  Make a db_run_state_t[] currently_processing.
  Loop indefinitely:
    Block, trying to decrement db_semaphore.
    Let operation_completed = false.
    For each db_run_state_t run_state in currently_processing:
      If length(run_state.request.response_queue) < db_response_buffer_length:
        Query the database
            for the next up to db_response_length records
            of the query run_state.request.query
            starting where run_state.progress indicates.
        Update run_state.progress based on the number of records returned, if necessary.
        Make a PDU_t[] PDUs of the records.
        Let is_done = false.
        Let db_semaphore_t more_data_semaphore = db_semaphore.
        If run_state.progress is at the end of run_state.request.query:
          Let is_done = true.
          Let more_data_semaphore = NULL.
          Remove run_state from currently_processing.
          Append an end-of-data PDU to PDUs.
        Add (PDUs, is_done, more_data_semaphore) to run_state.request.response_queue.
        Increment run_state.request.response_semaphore.
        Let operation_completed = true.
        Break the for each loop.
    If !operation_completed and db_request_queue can be popped:
      Pop db_request_queue into db_request_t db_request.
      Make a db_query_progress_t query_progress at the start of db_request.query.
      Add (db_request, query_progress) to currently_processing.
      Make a PDU_t[] start_PDUs that contains the start-of-data PDU appropriate for db_request.query.
      Add (start_PDUs, false, db_semaphore) to db_request.response_queue.
      Increment db_request.response_semaphore.
      Increment db_semaphore by (db_response_buffer_length - 1).

Connection control thread (socket_fd listen_fd, db_request_queue_t db_request_queue, db_semaphore_t[] db_semaphores_all, global_notify_state_t global_notify_state):
  Make a cxnctl_socket_map_t socket_map.
  Loop indefinitely:
    select() on listen_fd and all keys of socket_map.
    For each socket_fd_t cxn_socket in keys(socket_map) that's read-ready:
      Increment socket_map(cxn_socket).
    If listen_fd is accept-ready:
      Let socket_fd_t cxn_socket = accept(listen_fd, ...).
      Make a cxn_semaphore_t cxn_semaphore.
      Add (cxn_socket, cxn_semaphore) to socket_map.
      Spawn a connection thread with (cxn_socket, cxn_semaphore, db_request_queue, db_semaphores_all, global_notify_state).

Connection thread (socket_fd_t cxn_socket, cxn_semaphore_t cxn_semaphore, db_request_queue_t db_request_queue, db_semaphore_t[] db_semaphores_all):
  Create a queue of db responses from the database {db request, bool is_done, array of response PDUs, more data semaphore}. // NOTE: this only has responses to one db request at a time
  Create a local queue of parsed and validated PDUs to be processed when the current db request is completed (i.e. is_done is set on a db response).
  Create a PDU reassembly buffer of constant size.
  Create a state variable in the READY state.
  Create a local notify state as a non-locked copy of the global notify state.
  Loop indefinitely:
    Block for at most some time interval, trying to decrement the semaphore.
    If the socket is read-ready:
      Block, reading and appending to the buffer only enough bytes to get the length field.
      If the partial PDU is invalid or the length is too large for the reassembly buffer:
        Send an error report PDU and log an error.
        Quit thread.
      Block, reading and appending to the buffer as many bytes as the length field specifies.
      Parse the PDU.
      If the PDU can be handled/responded to without any database interaction in the current state:
        Block, handling/responding as necessary.
      Else if state is RESPONDING:
        Add the PDU to the queue of to-be-processed PDUs.
      Else:
        Add (db request, db response queue, our semaphore) to the database request queue and increment each of the queue's semaphores.
        Set state to RESPONDING.
    Else if there is something on the db response queue:
      Pop it from the queue.
      If the more data semaphore is not NULL:
        Increment the more data semaphore.
      If any of the db response PDUs indicate an update to local notify state:
        Update local notify state as appropriate.
      Block, sending the db response PDUs.
      If its is_done is true:
        Set state to READY.
        While the to-be-processed queue is nonempty and state is READY:
          Pop the to-be-processed queue.
          If the PDU can be handled/responded to without any database interaction:
            Block, handling/responding as necessary.
          Else:
            Add (db request, db response queue, our semaphore) to the database request queue and increment each of the queue's semaphores.
            Set state to RESPONDING.
    If state is READY:
      Create tmp notify state as a non-locked copy of the global notify state.
      If local notify state is earlier than tmp notify state:
        Block, sending notify PDU(s) for the differences from local notify state to tmp notify state.
        Set local notify state to tmp notify state.

=====================
Example Program Flows
---------------------

Example 1: Flow of control during "Start or Restart"
http://tools.ietf.org/html/draft-ietf-sidr-rpki-rtr-19#section-6.1

   Cache                         Router
     ~                             ~
     | <----- Reset Query -------- | R requests data (or Serial Query)
     |                             |
     | ----- Cache Response -----> | C confirms request
     | ------- IPvX Prefix ------> | C sends zero or more
     | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix
     | ------- IPvX Prefix ------> |   Payload PDUs
     | ------  End of Data ------> | C sends End of Data
     |                             |   and sends new serial
     ~                             ~

???


Example 2: Program flow during "Typical Exchange"
http://tools.ietf.org/html/draft-ietf-sidr-rpki-rtr-19#section-6.2

   Cache                         Router
     ~                             ~
     | -------- Notify ----------> |  (optional)
     |                             |
     | <----- Serial Query ------- | R requests data
     |                             |
     | ----- Cache Response -----> | C confirms request
     | ------- IPvX Prefix ------> | C sends zero or more
     | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix
     | ------- IPvX Prefix ------> |   Payload PDUs
     | ------  End of Data ------> | C sends End of Data
     |                             |   and sends new serial
     ~                             ~

???


Example 3: Program flow during "Cache has No Data Available"
http://tools.ietf.org/html/draft-ietf-sidr-rpki-rtr-19#section-6.4

   Cache                         Router
     ~                             ~
     | <-----  Serial Query ------ | R requests data
     | ---- Error Report PDU ----> | C No Data Available
     ~                             ~

???


Example 4: Program flow in case of "Error"
???
