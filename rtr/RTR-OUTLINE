=====================================
Top-level requirements for RTR server
-------------------------------------

T1. Provide timely, validated route origin information to multiple
    router clients, as specified in
    http://datatracker.ietf.org/doc/draft-ietf-sidr-rpki-rtr/

T2. Security requirement: Availability of route origin information.
    Client A must not be able to deny service to client B.

T3. Security requirement: (Currently optional) Integrity of route
    origin information.  RTR spec lists options such as TCP-AO, SSH,
    IPsec, and TLS.

Threat Model:

* Who/Motivation: Adversary wishing to alter routing through DoS of
  RTR server.
  
* Capability: Fully control/impersonate one or more RTR clients.  Can
  initiate arbitrary client connections, and send arbitrary data over
  RTR transport.

Explicit non-requirements:

* Confidentiality of route origin information is not required, since
  the information is publicly available.


===================================
Derived requirements for RTR server
-----------------------------------

D1. (Derived from T1). The RTR server will create periodic snapshots
    of the validated cache of ROAs, computing diffs and setting a new
    serial number each time.

D2. (Derived from T2). Basic authentication of client: firewall.  The RTR
    server is ASSUMED to sit behind a firewall that will (1) limit RTR
    clients to a set of pre-configured IP addresses, and (2) limit the
    number of concurrent connections from each IP address.
    
D3. (Derived from T2). Rate limit on queries.  The RTR server must limit
    the number of queries per connection, possibly by type of query, since
    reset queries can be expensive.

D4. (Derived from T1 and T2). Threads and timeouts.  Another way to abuse the
    system is when the server reads a message from a client and the
    actual transmission rate is *purposefully* very low. This should
    not stall all other clients.

D5. (Derived from T3). Future support for authenticated transport.
    RTR server is initially designed to support vanilla TCP only.
    Advanced functionality can be obtained through network shims such
    as netcat/ssh-subsystem, or stunnel.

D6. (Derived from T1 and T2).  The server should handle graceful
    shutdown, e.g. due to signal reception such as SIGINT.  A signal
    should not abruptly terminate the server process, which is the
    default behavior, but instead perform a graceful shutdown of all
    active connections. Signal handling procedure must be carefully
    written since it can easily induce race-conditions.

D7. (Derived from T1 and D2).  TCP keepalive.  To prevent inactivity
    from disconnecting the channel (e.g. due to firewall), and to
    reliably detect dead peers, keepalive should be enabled if the
    underlying OS supports it.


=======================
Problems to figure out:
-----------------------

 * In the current design, the connection control thread can spin on a socket that's read-ready, incrementing the corresponding semaphore many times before the connection thread reads all available data.
  * Possible fix: after incrementing a semaphore, remove the socket from the FD_SET and have the connection thread add it back somehow. This is probably problematic though.


===============
Design Overview
---------------

Threads (and short name as used below):
 . Main thread (main)
 . Database threads (db)
 . Connection control thread (cxnctl)
 . Connection threads (cxn)

Configuration parameters and constants:
 . initial_db_threads: number of db threads to start initially
 . main_loop_interval: number of seconds for main to sleep between each run through its management loop
 . db_response_length: number of records query for and include in a single db_response_t
 . db_response_buffer_length: number of db_response_t's to buffer in a db_response_queue_t per db_request_t
 . max_PDU_size: largest PDU to attempt to parse
 . cxn_notify_check_interval: maximum number of seconds (more or less) that connection should wait between checks if the global notify state has changed
 . cxn_timeout: longest amount of time to wait for something that should be ready "soon," e.g. the ability to send an error report PDU.

Data and synchronization types and structures:
 . socket_fd_t: whatever the system wants it to be
 . db_connection_t: whatever ODBC wants it to be

 . notify_state_t: serial number
 . global_notify_state_t: {notify_state_t notify_state, rwlock_t lock}

 . db_query_t: something that indicates what the router/client wants
 . db_query_progress_t: something that indicates where in a suspended SQL query to pick up

 . PDU_t: data of a parsed and valid PDU
 . PDU_buffer_t: uint8_t[max_PDU_size]

 . cxn_semaphore_t: semaphore that a cxn thread waits for
 . db_semaphore_t: semaphore that a db thread waits for

 . db_request_t: {db_query_t query, db_response_queue_t response_queue, cxn_semaphore_t response_semaphore}
 . db_request_queue_t: thread-safe queue of db_request_t

 . db_response_t: {PDU_t[] PDUs, bool is_done, db_semaphore_t more_data_semaphore}
 . db_response_queue_t: thread-safe queue of db_response_t

 . db_run_state_t: {db_request_t request, db_query_progress_t progress}

 . cxnctl_socket_map_t: map of socket_fd_t to cxn_semaphore_t

 . cxn_state_t: enum {READY, RESPONDING}
 . cxn_to_process_queue_t: queue of PDU_t


Variables (not including short-lived local variables):
+------------------------+------------------------------+------------+-------------+
| Type                   |  Variable                    | Created by | Used by     |
+------------------------+------------------------------+------------+-------------+
| socket_fd_t            | listen_fd                    | main       | cxnctl      |
| db_request_queue_t     | db_request_queue             | main       | db, cxn     |
| db_semaphore_t[]       | db_semaphores_all            | main       | cxn         |
| global_notify_state_t  | global_notify_state          | main       | main, cxn   |
| db_semaphore_t         | db_semaphore per db thread   | main       | db          |
| db_connection_t        | notify().connection          | main       | main        |
| db_connection_t        | <unnamed>                    | db         | db          |
| db_run_state_t[]       | currently_processing         | db         | db          |
| cxnctl_socket_map_t    | socket_map                   | cxnctl     | cxnctl      |
| socket_fd_t            | cxn_socket per cxn thread    | cxnctl     | cxnctl, cxn |
| cxn_semaphore_t        | cxn_semaphore per cxn thread | cxnctl     | cxnctl, cxn |
| db_response_queue_t    | db_response_queue            | cxn        | cxn, db     |
| cxn_to_process_queue_t | to_process_queue             | cxn        | cxn         |
| PDU_buffer_t           | pdu_buffer                   | cxn        | cxn         |
| cxn_state_t            | cxn_state                    | cxn        | cxn         |
| notify_state_t         | notify_state                 | cxn        | cxn         |
+------------------------+------------------------------+------------+-------------+

Note that `[]' is used to denote a container, not necessarily a C array.


===============
Detailed Design
---------------

Main thread:
  Make a socket_fd_t listen_fd in the listening state.
  Make a db_request_queue_t db_request_queue.
  Make a db_semaphore_t[] db_semaphores_all.
  Make a global_notify_state_t global_notify_state.
  Call notify state update function on (global_notify_state).
  Repeat initial_db_threads times:
    Make a db_semaphore_t db_semaphore.
    Add db_semaphore to db_semaphores_all.
    Spawn a database thread with (db_semaphore, db_request_queue).
  Spawn a connection control thread with (listen_fd, db_request_queue, db_semaphores_all, global_notify_state).
  Loop indefinitely:
    Sleep for main_loop_interval seconds.
    Check the load on the database threads, adding or removing threads as needed.
    Call notify state update function on (global_notify_state).

Notify state update function (global_notify_state_t global_notify_state):
  Static db_connection_t connection.
  If connection isn't connected:
    Connect to database.
  Acquire global_notify_state.lock for writing.
  Update global_notify_state.notify_state based on a database query.
  Release global_notify_state.lock.
 
Database thread (db_semaphore_t db_semaphore, db_request_queue_t db_request_queue):
  Connect to database.
  Make a db_run_state_t[] currently_processing.
  Loop indefinitely:
    Block, trying to decrement db_semaphore.
    Let operation_completed = false.
    For each db_run_state_t run_state in currently_processing:
      If length(run_state.request.response_queue) < db_response_buffer_length:
        Query the database
            for the next up to db_response_length records
            of the query run_state.request.query
            starting where run_state.progress indicates.
        Update run_state.progress based on the number of records returned, if necessary.
        Make a PDU_t[] PDUs of the records.
        Let is_done = false.
        Let db_semaphore_t more_data_semaphore = db_semaphore.
        If run_state.progress is at the end of run_state.request.query:
          Let is_done = true.
          Let more_data_semaphore = NULL.
          Remove run_state from currently_processing.
          Append an end-of-data PDU to PDUs.
        Add (PDUs, is_done, more_data_semaphore) to run_state.request.response_queue.
        Increment run_state.request.response_semaphore.
        Let operation_completed = true.
        Break the for each loop.
    If !operation_completed and db_request_queue can be popped:
      Pop db_request_queue into db_request_t db_request.
      Make a db_query_progress_t query_progress at the start of db_request.query.
      Add (db_request, query_progress) to currently_processing.
      Make a PDU_t[] start_PDUs that contains the start-of-data PDU appropriate for db_request.query.
      Add (start_PDUs, false, db_semaphore) to db_request.response_queue.
      Increment db_request.response_semaphore.
      Increment db_semaphore by (db_response_buffer_length - 1).

Connection control thread (socket_fd listen_fd, db_request_queue_t db_request_queue, db_semaphore_t[] db_semaphores_all, global_notify_state_t global_notify_state):
  Make a cxnctl_socket_map_t socket_map.
  Loop indefinitely:
    select() on listen_fd and all keys of socket_map.
    For each socket_fd_t cxn_socket in keys(socket_map) that's read-ready:
      Increment socket_map(cxn_socket).
    If listen_fd is accept-ready:
      Let socket_fd_t cxn_socket = accept(listen_fd, ...).
      Make a cxn_semaphore_t cxn_semaphore.
      Add (cxn_socket, cxn_semaphore) to socket_map.
      Spawn a connection thread with (cxn_socket, cxn_semaphore, db_request_queue, db_semaphores_all, global_notify_state).

Connection thread (socket_fd_t cxn_socket, cxn_semaphore_t cxn_semaphore, db_request_queue_t db_request_queue, db_semaphore_t[] db_semaphores_all, global_notify_state_t global_notify_state):
  Make a db_response_queue_t db_response_queue. // NOTE: this only has responses to one db request at a time
  Make a cxn_to_process_queue_t to_process_queue. // PDUs to be processed when the current db request is completed (i.e. is_done is set on a db_response_t in db_response_queue).
  Make a PDU_buffer_t pdu_buffer.
  Let cxn_state_t cxn_state = READY.
  Lock global_notify_state.lock for reading.
  Let notify_state_t notify_state = copy of global_notify_state.notify_state.
  Unlock global_notify_state.lock.
  Loop indefinitely:
    Block for at most cxn_notify_check_interval, trying to decrement cxn_semaphore.
    If cxn_socket is read-ready:
      Block, reading from cxn_socket into pdu_buffer only enough bytes to get the PDU length field.
      If the partial PDU in pdu_buffer is invalid or its advertised length is larger than max_PDU_size:
        Log an error.
        Block for at most cxn_timeout, sending an error report PDU.
        Close cxn_socket.
        Quit thread.
      Block, reading from cxn_socket and appending to pdu_buffer as many bytes as the length field specifies.
      Parse the PDU into PDU_t pdu.
      If the PDU can be handled/responded to without any database interaction in the current state: // This includes if the PDU is invalid or if it's an error report PDU.
        Block, handling/responding as necessary.
      Else if cxn_state is RESPONDING:
        Add pdu to to_process_queue.
      Else:
        Call add_db_request with (pdu, db_response_queue, cxn_semaphore, db_request_queue, db_semaphores_all).
        Set cxn_state to RESPONDING.
    Else if db_response_queue can be popped:
      Let db_response_t response = pop from db_response_queue.
      If response.more_data_semaphore is not NULL:
        Increment response.more_data_semaphore.
      If any of response.PDUs indicate an update to notify_state:
        Update notify_state as appropriate.
      Block, sending response.PDUs over cxn_socket.
      If response.is_done:
        Set cxn_state to READY.
        While to_process_queue is nonempty and cxn_state is READY:
          Let PDU_t pdu = pop to_process_queue.
          If pdu can be handled/responded to without any database interaction:
            Block, handling/responding as necessary.
          Else:
            Call add_db_request with (pdu, db_response_queue, cxn_semaphore, db_request_queue, db_semaphores_all).
            Set cxn_state to RESPONDING.
    If cxn_state is READY:
      Lock global_notify_state.lock for reading.
      Let notify_state_t tmp_notify_state = copy of global_notify_state.notify_state.
      Unlock global_notify_state.lock.
      If notify_state is earlier than tmp_notify_state:
        Block, sending notify PDU(s) for the differences from notify_state to tmp_notify_state over cxn_socket.
        Set notify_state to tmp_notify_state.

Function add_db_request(PDU_t pdu, db_response_queue_t db_response_queue, cxn_semaphore_t cxn_semaphore, db_request_queue_t db_request_queue, db_semaphore_t[] db_semaphores_all):
  Assert db_response_queue is empty.
  Let db_query_t query = the query indicated by pdu.
  Add (query, db_response_queue, cxn_semaphore) to db_request_queue.
  For each db_semaphore_t sem in db_semaphores_all:
    Increment sem.

=====================
Example Program Flows
---------------------

Example 1: Flow of control during "Start or Restart"
http://tools.ietf.org/html/draft-ietf-sidr-rpki-rtr-19#section-6.1

   Cache                         Router
     ~                             ~
     | <----- Reset Query -------- | R requests data (or Serial Query)
     |                             |
     | ----- Cache Response -----> | C confirms request
     | ------- IPvX Prefix ------> | C sends zero or more
     | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix
     | ------- IPvX Prefix ------> |   Payload PDUs
     | ------  End of Data ------> | C sends End of Data
     |                             |   and sends new serial
     ~                             ~

???


Example 2: Program flow during "Typical Exchange"
http://tools.ietf.org/html/draft-ietf-sidr-rpki-rtr-19#section-6.2

   Cache                         Router
     ~                             ~
     | -------- Notify ----------> |  (optional)
     |                             |
     | <----- Serial Query ------- | R requests data
     |                             |
     | ----- Cache Response -----> | C confirms request
     | ------- IPvX Prefix ------> | C sends zero or more
     | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix
     | ------- IPvX Prefix ------> |   Payload PDUs
     | ------  End of Data ------> | C sends End of Data
     |                             |   and sends new serial
     ~                             ~

???


Example 3: Program flow during "Cache has No Data Available"
http://tools.ietf.org/html/draft-ietf-sidr-rpki-rtr-19#section-6.4

   Cache                         Router
     ~                             ~
     | <-----  Serial Query ------ | R requests data
     | ---- Error Report PDU ----> | C No Data Available
     ~                             ~

???


Example 4: Program flow in case of "Error"
???
